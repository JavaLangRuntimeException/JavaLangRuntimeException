"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/jotai";
exports.ids = ["vendor-chunks/jotai"];
exports.modules = {

/***/ "(ssr)/./node_modules/jotai/esm/react.mjs":
/*!******************************************!*\
  !*** ./node_modules/jotai/esm/react.mjs ***!
  \******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Provider: () => (/* binding */ Provider),\n/* harmony export */   useAtom: () => (/* binding */ useAtom),\n/* harmony export */   useAtomValue: () => (/* binding */ useAtomValue),\n/* harmony export */   useSetAtom: () => (/* binding */ useSetAtom),\n/* harmony export */   useStore: () => (/* binding */ useStore)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jotai/vanilla */ \"(ssr)/./node_modules/jotai/esm/vanilla.mjs\");\n/* __next_internal_client_entry_do_not_use__ Provider,useAtom,useAtomValue,useSetAtom,useStore auto */ \n\nconst StoreContext = /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createContext)(undefined);\nconst useStore = (options)=>{\n    const store = (0,react__WEBPACK_IMPORTED_MODULE_0__.useContext)(StoreContext);\n    return (options == null ? undefined : options.store) || store || (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.getDefaultStore)();\n};\nconst Provider = ({ children, store })=>{\n    const storeRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(undefined);\n    if (!store && !storeRef.current) {\n        storeRef.current = (0,jotai_vanilla__WEBPACK_IMPORTED_MODULE_1__.createStore)();\n    }\n    return /*#__PURE__*/ (0,react__WEBPACK_IMPORTED_MODULE_0__.createElement)(StoreContext.Provider, {\n        value: store || storeRef.current\n    }, children);\n};\nconst isPromiseLike = (x)=>typeof (x == null ? undefined : x.then) === \"function\";\nconst attachPromiseMeta = (promise)=>{\n    promise.status = \"pending\";\n    promise.then((v)=>{\n        promise.status = \"fulfilled\";\n        promise.value = v;\n    }, (e)=>{\n        promise.status = \"rejected\";\n        promise.reason = e;\n    });\n};\nconst use = react__WEBPACK_IMPORTED_MODULE_0__.use || ((promise)=>{\n    if (promise.status === \"pending\") {\n        throw promise;\n    } else if (promise.status === \"fulfilled\") {\n        return promise.value;\n    } else if (promise.status === \"rejected\") {\n        throw promise.reason;\n    } else {\n        attachPromiseMeta(promise);\n        throw promise;\n    }\n});\nconst continuablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst createContinuablePromise = (promise)=>{\n    let continuablePromise = continuablePromiseMap.get(promise);\n    if (!continuablePromise) {\n        continuablePromise = new Promise((resolve, reject)=>{\n            let curr = promise;\n            const onFulfilled = (me)=>(v)=>{\n                    if (curr === me) {\n                        resolve(v);\n                    }\n                };\n            const onRejected = (me)=>(e)=>{\n                    if (curr === me) {\n                        reject(e);\n                    }\n                };\n            const registerCancelHandler = (p)=>{\n                if (\"onCancel\" in p && typeof p.onCancel === \"function\") {\n                    p.onCancel((nextValue)=>{\n                        if ( true && nextValue === p) {\n                            throw new Error(\"[Bug] p is not updated even after cancelation\");\n                        }\n                        if (isPromiseLike(nextValue)) {\n                            continuablePromiseMap.set(nextValue, continuablePromise);\n                            curr = nextValue;\n                            nextValue.then(onFulfilled(nextValue), onRejected(nextValue));\n                            registerCancelHandler(nextValue);\n                        } else {\n                            resolve(nextValue);\n                        }\n                    });\n                }\n            };\n            promise.then(onFulfilled(promise), onRejected(promise));\n            registerCancelHandler(promise);\n        });\n        continuablePromiseMap.set(promise, continuablePromise);\n    }\n    return continuablePromise;\n};\nfunction useAtomValue(atom, options) {\n    const store = useStore(options);\n    const [[valueFromReducer, storeFromReducer, atomFromReducer], rerender] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)({\n        \"useAtomValue.useReducer\": (prev)=>{\n            const nextValue = store.get(atom);\n            if (Object.is(prev[0], nextValue) && prev[1] === store && prev[2] === atom) {\n                return prev;\n            }\n            return [\n                nextValue,\n                store,\n                atom\n            ];\n        }\n    }[\"useAtomValue.useReducer\"], undefined, {\n        \"useAtomValue.useReducer\": ()=>[\n                store.get(atom),\n                store,\n                atom\n            ]\n    }[\"useAtomValue.useReducer\"]);\n    let value = valueFromReducer;\n    if (storeFromReducer !== store || atomFromReducer !== atom) {\n        rerender();\n        value = store.get(atom);\n    }\n    const delay = options == null ? undefined : options.delay;\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useAtomValue.useEffect\": ()=>{\n            const unsub = store.sub(atom, {\n                \"useAtomValue.useEffect.unsub\": ()=>{\n                    if (typeof delay === \"number\") {\n                        const value2 = store.get(atom);\n                        if (isPromiseLike(value2)) {\n                            attachPromiseMeta(createContinuablePromise(value2));\n                        }\n                        setTimeout(rerender, delay);\n                        return;\n                    }\n                    rerender();\n                }\n            }[\"useAtomValue.useEffect.unsub\"]);\n            rerender();\n            return unsub;\n        }\n    }[\"useAtomValue.useEffect\"], [\n        store,\n        atom,\n        delay\n    ]);\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(value);\n    if (isPromiseLike(value)) {\n        const promise = createContinuablePromise(value);\n        return use(promise);\n    }\n    return value;\n}\nfunction useSetAtom(atom, options) {\n    const store = useStore(options);\n    const setAtom = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useSetAtom.useCallback[setAtom]\": (...args)=>{\n            if ( true && !(\"write\" in atom)) {\n                throw new Error(\"not writable atom\");\n            }\n            return store.set(atom, ...args);\n        }\n    }[\"useSetAtom.useCallback[setAtom]\"], [\n        store,\n        atom\n    ]);\n    return setAtom;\n}\nfunction useAtom(atom, options) {\n    return [\n        useAtomValue(atom, options),\n        // We do wrong type assertion here, which results in throwing an error.\n        useSetAtom(atom, options)\n    ];\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O3VHQUMwSTtBQUM3RTtBQUU3RCxNQUFNVyw2QkFBZVYsb0RBQWFBLENBQ2hDVztBQUVGLE1BQU1DLFdBQVcsQ0FBQ0M7SUFDaEIsTUFBTUMsUUFBUWIsaURBQVVBLENBQUNTO0lBQ3pCLE9BQU8sQ0FBQ0csV0FBVyxPQUFPRixZQUFZRSxRQUFRQyxLQUFLLEtBQUtBLFNBQVNOLDhEQUFlQTtBQUNsRjtBQUNBLE1BQU1PLFdBQVcsQ0FBQyxFQUNoQkMsUUFBUSxFQUNSRixLQUFLLEVBQ047SUFDQyxNQUFNRyxXQUFXZiw2Q0FBTUEsQ0FBQ1M7SUFDeEIsSUFBSSxDQUFDRyxTQUFTLENBQUNHLFNBQVNDLE9BQU8sRUFBRTtRQUMvQkQsU0FBU0MsT0FBTyxHQUFHVCwwREFBV0E7SUFDaEM7SUFDQSxxQkFBT04sb0RBQWFBLENBQ2xCTyxhQUFhSyxRQUFRLEVBQ3JCO1FBQ0VJLE9BQU9MLFNBQVNHLFNBQVNDLE9BQU87SUFDbEMsR0FDQUY7QUFFSjtBQUVBLE1BQU1JLGdCQUFnQixDQUFDQyxJQUFNLE9BQVFBLENBQUFBLEtBQUssT0FBT1YsWUFBWVUsRUFBRUMsSUFBSSxNQUFNO0FBQ3pFLE1BQU1DLG9CQUFvQixDQUFDQztJQUN6QkEsUUFBUUMsTUFBTSxHQUFHO0lBQ2pCRCxRQUFRRixJQUFJLENBQ1YsQ0FBQ0k7UUFDQ0YsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRTCxLQUFLLEdBQUdPO0lBQ2xCLEdBQ0EsQ0FBQ0M7UUFDQ0gsUUFBUUMsTUFBTSxHQUFHO1FBQ2pCRCxRQUFRSSxNQUFNLEdBQUdEO0lBQ25CO0FBRUo7QUFDQSxNQUFNRSxNQUFNOUIsc0NBQWdCLElBQUssRUFBQ3lCO0lBQ2hDLElBQUlBLFFBQVFDLE1BQU0sS0FBSyxXQUFXO1FBQ2hDLE1BQU1EO0lBQ1IsT0FBTyxJQUFJQSxRQUFRQyxNQUFNLEtBQUssYUFBYTtRQUN6QyxPQUFPRCxRQUFRTCxLQUFLO0lBQ3RCLE9BQU8sSUFBSUssUUFBUUMsTUFBTSxLQUFLLFlBQVk7UUFDeEMsTUFBTUQsUUFBUUksTUFBTTtJQUN0QixPQUFPO1FBQ0xMLGtCQUFrQkM7UUFDbEIsTUFBTUE7SUFDUjtBQUNGO0FBQ0EsTUFBTU0sd0JBQXdCLGFBQWEsR0FBRyxJQUFJQztBQUNsRCxNQUFNQywyQkFBMkIsQ0FBQ1I7SUFDaEMsSUFBSVMscUJBQXFCSCxzQkFBc0JJLEdBQUcsQ0FBQ1Y7SUFDbkQsSUFBSSxDQUFDUyxvQkFBb0I7UUFDdkJBLHFCQUFxQixJQUFJRSxRQUFRLENBQUNDLFNBQVNDO1lBQ3pDLElBQUlDLE9BQU9kO1lBQ1gsTUFBTWUsY0FBYyxDQUFDQyxLQUFPLENBQUNkO29CQUMzQixJQUFJWSxTQUFTRSxJQUFJO3dCQUNmSixRQUFRVjtvQkFDVjtnQkFDRjtZQUNBLE1BQU1lLGFBQWEsQ0FBQ0QsS0FBTyxDQUFDYjtvQkFDMUIsSUFBSVcsU0FBU0UsSUFBSTt3QkFDZkgsT0FBT1Y7b0JBQ1Q7Z0JBQ0Y7WUFDQSxNQUFNZSx3QkFBd0IsQ0FBQ0M7Z0JBQzdCLElBQUksY0FBY0EsS0FBSyxPQUFPQSxFQUFFQyxRQUFRLEtBQUssWUFBWTtvQkFDdkRELEVBQUVDLFFBQVEsQ0FBQyxDQUFDQzt3QkFDVixJQUFJLEtBQXFFLElBQUlBLGNBQWNGLEdBQUc7NEJBQzVGLE1BQU0sSUFBSUssTUFBTTt3QkFDbEI7d0JBQ0EsSUFBSTVCLGNBQWN5QixZQUFZOzRCQUM1QmYsc0JBQXNCbUIsR0FBRyxDQUFDSixXQUFXWjs0QkFDckNLLE9BQU9POzRCQUNQQSxVQUFVdkIsSUFBSSxDQUFDaUIsWUFBWU0sWUFBWUosV0FBV0k7NEJBQ2xESCxzQkFBc0JHO3dCQUN4QixPQUFPOzRCQUNMVCxRQUFRUzt3QkFDVjtvQkFDRjtnQkFDRjtZQUNGO1lBQ0FyQixRQUFRRixJQUFJLENBQUNpQixZQUFZZixVQUFVaUIsV0FBV2pCO1lBQzlDa0Isc0JBQXNCbEI7UUFDeEI7UUFDQU0sc0JBQXNCbUIsR0FBRyxDQUFDekIsU0FBU1M7SUFDckM7SUFDQSxPQUFPQTtBQUNUO0FBQ0EsU0FBU2lCLGFBQWFDLElBQUksRUFBRXRDLE9BQU87SUFDakMsTUFBTUMsUUFBUUYsU0FBU0M7SUFDdkIsTUFBTSxDQUFDLENBQUN1QyxrQkFBa0JDLGtCQUFrQkMsZ0JBQWdCLEVBQUVDLFNBQVMsR0FBR25ELGlEQUFVQTttQ0FDbEYsQ0FBQ29EO1lBQ0MsTUFBTVgsWUFBWS9CLE1BQU1vQixHQUFHLENBQUNpQjtZQUM1QixJQUFJTSxPQUFPQyxFQUFFLENBQUNGLElBQUksQ0FBQyxFQUFFLEVBQUVYLGNBQWNXLElBQUksQ0FBQyxFQUFFLEtBQUsxQyxTQUFTMEMsSUFBSSxDQUFDLEVBQUUsS0FBS0wsTUFBTTtnQkFDMUUsT0FBT0s7WUFDVDtZQUNBLE9BQU87Z0JBQUNYO2dCQUFXL0I7Z0JBQU9xQzthQUFLO1FBQ2pDO2tDQUNBeEM7bUNBQ0EsSUFBTTtnQkFBQ0csTUFBTW9CLEdBQUcsQ0FBQ2lCO2dCQUFPckM7Z0JBQU9xQzthQUFLOztJQUV0QyxJQUFJaEMsUUFBUWlDO0lBQ1osSUFBSUMscUJBQXFCdkMsU0FBU3dDLG9CQUFvQkgsTUFBTTtRQUMxREk7UUFDQXBDLFFBQVFMLE1BQU1vQixHQUFHLENBQUNpQjtJQUNwQjtJQUNBLE1BQU1RLFFBQVE5QyxXQUFXLE9BQU9GLFlBQVlFLFFBQVE4QyxLQUFLO0lBQ3pEdEQsZ0RBQVNBO2tDQUFDO1lBQ1IsTUFBTXVELFFBQVE5QyxNQUFNK0MsR0FBRyxDQUFDVjtnREFBTTtvQkFDNUIsSUFBSSxPQUFPUSxVQUFVLFVBQVU7d0JBQzdCLE1BQU1HLFNBQVNoRCxNQUFNb0IsR0FBRyxDQUFDaUI7d0JBQ3pCLElBQUkvQixjQUFjMEMsU0FBUzs0QkFDekJ2QyxrQkFBa0JTLHlCQUF5QjhCO3dCQUM3Qzt3QkFDQUMsV0FBV1IsVUFBVUk7d0JBQ3JCO29CQUNGO29CQUNBSjtnQkFDRjs7WUFDQUE7WUFDQSxPQUFPSztRQUNUO2lDQUFHO1FBQUM5QztRQUFPcUM7UUFBTVE7S0FBTTtJQUN2QnJELG9EQUFhQSxDQUFDYTtJQUNkLElBQUlDLGNBQWNELFFBQVE7UUFDeEIsTUFBTUssVUFBVVEseUJBQXlCYjtRQUN6QyxPQUFPVSxJQUFJTDtJQUNiO0lBQ0EsT0FBT0w7QUFDVDtBQUVBLFNBQVM2QyxXQUFXYixJQUFJLEVBQUV0QyxPQUFPO0lBQy9CLE1BQU1DLFFBQVFGLFNBQVNDO0lBQ3ZCLE1BQU1vRCxVQUFVMUQsa0RBQVdBOzJDQUN6QixDQUFDLEdBQUcyRDtZQUNGLElBQUksS0FBcUUsSUFBSSxDQUFFLFlBQVdmLElBQUcsR0FBSTtnQkFDL0YsTUFBTSxJQUFJSCxNQUFNO1lBQ2xCO1lBQ0EsT0FBT2xDLE1BQU1tQyxHQUFHLENBQUNFLFNBQVNlO1FBQzVCOzBDQUNBO1FBQUNwRDtRQUFPcUM7S0FBSztJQUVmLE9BQU9jO0FBQ1Q7QUFFQSxTQUFTRSxRQUFRaEIsSUFBSSxFQUFFdEMsT0FBTztJQUM1QixPQUFPO1FBQ0xxQyxhQUFhQyxNQUFNdEM7UUFDbkIsdUVBQXVFO1FBQ3ZFbUQsV0FBV2IsTUFBTXRDO0tBQ2xCO0FBQ0g7QUFFaUUiLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy90YW5haC9naXQvSmF2YUxhbmdSdW50aW1lRXhjZXB0aW9uLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvam90YWkvZXNtL3JlYWN0Lm1qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XG5pbXBvcnQgUmVhY3RFeHBvcnRzLCB7IGNyZWF0ZUNvbnRleHQsIHVzZUNvbnRleHQsIHVzZVJlZiwgY3JlYXRlRWxlbWVudCwgdXNlUmVkdWNlciwgdXNlRWZmZWN0LCB1c2VEZWJ1Z1ZhbHVlLCB1c2VDYWxsYmFjayB9IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IGdldERlZmF1bHRTdG9yZSwgY3JlYXRlU3RvcmUgfSBmcm9tICdqb3RhaS92YW5pbGxhJztcblxuY29uc3QgU3RvcmVDb250ZXh0ID0gY3JlYXRlQ29udGV4dChcbiAgdW5kZWZpbmVkXG4pO1xuY29uc3QgdXNlU3RvcmUgPSAob3B0aW9ucykgPT4ge1xuICBjb25zdCBzdG9yZSA9IHVzZUNvbnRleHQoU3RvcmVDb250ZXh0KTtcbiAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB1bmRlZmluZWQgOiBvcHRpb25zLnN0b3JlKSB8fCBzdG9yZSB8fCBnZXREZWZhdWx0U3RvcmUoKTtcbn07XG5jb25zdCBQcm92aWRlciA9ICh7XG4gIGNoaWxkcmVuLFxuICBzdG9yZVxufSkgPT4ge1xuICBjb25zdCBzdG9yZVJlZiA9IHVzZVJlZih1bmRlZmluZWQpO1xuICBpZiAoIXN0b3JlICYmICFzdG9yZVJlZi5jdXJyZW50KSB7XG4gICAgc3RvcmVSZWYuY3VycmVudCA9IGNyZWF0ZVN0b3JlKCk7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUVsZW1lbnQoXG4gICAgU3RvcmVDb250ZXh0LlByb3ZpZGVyLFxuICAgIHtcbiAgICAgIHZhbHVlOiBzdG9yZSB8fCBzdG9yZVJlZi5jdXJyZW50XG4gICAgfSxcbiAgICBjaGlsZHJlblxuICApO1xufTtcblxuY29uc3QgaXNQcm9taXNlTGlrZSA9ICh4KSA9PiB0eXBlb2YgKHggPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHgudGhlbikgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGF0dGFjaFByb21pc2VNZXRhID0gKHByb21pc2UpID0+IHtcbiAgcHJvbWlzZS5zdGF0dXMgPSBcInBlbmRpbmdcIjtcbiAgcHJvbWlzZS50aGVuKFxuICAgICh2KSA9PiB7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwiZnVsZmlsbGVkXCI7XG4gICAgICBwcm9taXNlLnZhbHVlID0gdjtcbiAgICB9LFxuICAgIChlKSA9PiB7XG4gICAgICBwcm9taXNlLnN0YXR1cyA9IFwicmVqZWN0ZWRcIjtcbiAgICAgIHByb21pc2UucmVhc29uID0gZTtcbiAgICB9XG4gICk7XG59O1xuY29uc3QgdXNlID0gUmVhY3RFeHBvcnRzLnVzZSB8fCAoKHByb21pc2UpID0+IHtcbiAgaWYgKHByb21pc2Uuc3RhdHVzID09PSBcInBlbmRpbmdcIikge1xuICAgIHRocm93IHByb21pc2U7XG4gIH0gZWxzZSBpZiAocHJvbWlzZS5zdGF0dXMgPT09IFwiZnVsZmlsbGVkXCIpIHtcbiAgICByZXR1cm4gcHJvbWlzZS52YWx1ZTtcbiAgfSBlbHNlIGlmIChwcm9taXNlLnN0YXR1cyA9PT0gXCJyZWplY3RlZFwiKSB7XG4gICAgdGhyb3cgcHJvbWlzZS5yZWFzb247XG4gIH0gZWxzZSB7XG4gICAgYXR0YWNoUHJvbWlzZU1ldGEocHJvbWlzZSk7XG4gICAgdGhyb3cgcHJvbWlzZTtcbiAgfVxufSk7XG5jb25zdCBjb250aW51YWJsZVByb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGNyZWF0ZUNvbnRpbnVhYmxlUHJvbWlzZSA9IChwcm9taXNlKSA9PiB7XG4gIGxldCBjb250aW51YWJsZVByb21pc2UgPSBjb250aW51YWJsZVByb21pc2VNYXAuZ2V0KHByb21pc2UpO1xuICBpZiAoIWNvbnRpbnVhYmxlUHJvbWlzZSkge1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGxldCBjdXJyID0gcHJvbWlzZTtcbiAgICAgIGNvbnN0IG9uRnVsZmlsbGVkID0gKG1lKSA9PiAodikgPT4ge1xuICAgICAgICBpZiAoY3VyciA9PT0gbWUpIHtcbiAgICAgICAgICByZXNvbHZlKHYpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3Qgb25SZWplY3RlZCA9IChtZSkgPT4gKGUpID0+IHtcbiAgICAgICAgaWYgKGN1cnIgPT09IG1lKSB7XG4gICAgICAgICAgcmVqZWN0KGUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgY29uc3QgcmVnaXN0ZXJDYW5jZWxIYW5kbGVyID0gKHApID0+IHtcbiAgICAgICAgaWYgKFwib25DYW5jZWxcIiBpbiBwICYmIHR5cGVvZiBwLm9uQ2FuY2VsID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICBwLm9uQ2FuY2VsKChuZXh0VmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB1bmRlZmluZWQpICE9PSBcInByb2R1Y3Rpb25cIiAmJiBuZXh0VmFsdWUgPT09IHApIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiW0J1Z10gcCBpcyBub3QgdXBkYXRlZCBldmVuIGFmdGVyIGNhbmNlbGF0aW9uXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUxpa2UobmV4dFZhbHVlKSkge1xuICAgICAgICAgICAgICBjb250aW51YWJsZVByb21pc2VNYXAuc2V0KG5leHRWYWx1ZSwgY29udGludWFibGVQcm9taXNlKTtcbiAgICAgICAgICAgICAgY3VyciA9IG5leHRWYWx1ZTtcbiAgICAgICAgICAgICAgbmV4dFZhbHVlLnRoZW4ob25GdWxmaWxsZWQobmV4dFZhbHVlKSwgb25SZWplY3RlZChuZXh0VmFsdWUpKTtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJDYW5jZWxIYW5kbGVyKG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXNvbHZlKG5leHRWYWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBwcm9taXNlLnRoZW4ob25GdWxmaWxsZWQocHJvbWlzZSksIG9uUmVqZWN0ZWQocHJvbWlzZSkpO1xuICAgICAgcmVnaXN0ZXJDYW5jZWxIYW5kbGVyKHByb21pc2UpO1xuICAgIH0pO1xuICAgIGNvbnRpbnVhYmxlUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgY29udGludWFibGVQcm9taXNlKTtcbiAgfVxuICByZXR1cm4gY29udGludWFibGVQcm9taXNlO1xufTtcbmZ1bmN0aW9uIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IFtbdmFsdWVGcm9tUmVkdWNlciwgc3RvcmVGcm9tUmVkdWNlciwgYXRvbUZyb21SZWR1Y2VyXSwgcmVyZW5kZXJdID0gdXNlUmVkdWNlcihcbiAgICAocHJldikgPT4ge1xuICAgICAgY29uc3QgbmV4dFZhbHVlID0gc3RvcmUuZ2V0KGF0b20pO1xuICAgICAgaWYgKE9iamVjdC5pcyhwcmV2WzBdLCBuZXh0VmFsdWUpICYmIHByZXZbMV0gPT09IHN0b3JlICYmIHByZXZbMl0gPT09IGF0b20pIHtcbiAgICAgICAgcmV0dXJuIHByZXY7XG4gICAgICB9XG4gICAgICByZXR1cm4gW25leHRWYWx1ZSwgc3RvcmUsIGF0b21dO1xuICAgIH0sXG4gICAgdW5kZWZpbmVkLFxuICAgICgpID0+IFtzdG9yZS5nZXQoYXRvbSksIHN0b3JlLCBhdG9tXVxuICApO1xuICBsZXQgdmFsdWUgPSB2YWx1ZUZyb21SZWR1Y2VyO1xuICBpZiAoc3RvcmVGcm9tUmVkdWNlciAhPT0gc3RvcmUgfHwgYXRvbUZyb21SZWR1Y2VyICE9PSBhdG9tKSB7XG4gICAgcmVyZW5kZXIoKTtcbiAgICB2YWx1ZSA9IHN0b3JlLmdldChhdG9tKTtcbiAgfVxuICBjb25zdCBkZWxheSA9IG9wdGlvbnMgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9wdGlvbnMuZGVsYXk7XG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWIoYXRvbSwgKCkgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBjb25zdCB2YWx1ZTIgPSBzdG9yZS5nZXQoYXRvbSk7XG4gICAgICAgIGlmIChpc1Byb21pc2VMaWtlKHZhbHVlMikpIHtcbiAgICAgICAgICBhdHRhY2hQcm9taXNlTWV0YShjcmVhdGVDb250aW51YWJsZVByb21pc2UodmFsdWUyKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGltZW91dChyZXJlbmRlciwgZGVsYXkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXJlbmRlcigpO1xuICAgIH0pO1xuICAgIHJlcmVuZGVyKCk7XG4gICAgcmV0dXJuIHVuc3ViO1xuICB9LCBbc3RvcmUsIGF0b20sIGRlbGF5XSk7XG4gIHVzZURlYnVnVmFsdWUodmFsdWUpO1xuICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZSkpIHtcbiAgICBjb25zdCBwcm9taXNlID0gY3JlYXRlQ29udGludWFibGVQcm9taXNlKHZhbHVlKTtcbiAgICByZXR1cm4gdXNlKHByb21pc2UpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlU2V0QXRvbShhdG9tLCBvcHRpb25zKSB7XG4gIGNvbnN0IHN0b3JlID0gdXNlU3RvcmUob3B0aW9ucyk7XG4gIGNvbnN0IHNldEF0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoLi4uYXJncykgPT4ge1xuICAgICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHVuZGVmaW5lZCkgIT09IFwicHJvZHVjdGlvblwiICYmICEoXCJ3cml0ZVwiIGluIGF0b20pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vdCB3cml0YWJsZSBhdG9tXCIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0b3JlLnNldChhdG9tLCAuLi5hcmdzKTtcbiAgICB9LFxuICAgIFtzdG9yZSwgYXRvbV1cbiAgKTtcbiAgcmV0dXJuIHNldEF0b207XG59XG5cbmZ1bmN0aW9uIHVzZUF0b20oYXRvbSwgb3B0aW9ucykge1xuICByZXR1cm4gW1xuICAgIHVzZUF0b21WYWx1ZShhdG9tLCBvcHRpb25zKSxcbiAgICAvLyBXZSBkbyB3cm9uZyB0eXBlIGFzc2VydGlvbiBoZXJlLCB3aGljaCByZXN1bHRzIGluIHRocm93aW5nIGFuIGVycm9yLlxuICAgIHVzZVNldEF0b20oYXRvbSwgb3B0aW9ucylcbiAgXTtcbn1cblxuZXhwb3J0IHsgUHJvdmlkZXIsIHVzZUF0b20sIHVzZUF0b21WYWx1ZSwgdXNlU2V0QXRvbSwgdXNlU3RvcmUgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdEV4cG9ydHMiLCJjcmVhdGVDb250ZXh0IiwidXNlQ29udGV4dCIsInVzZVJlZiIsImNyZWF0ZUVsZW1lbnQiLCJ1c2VSZWR1Y2VyIiwidXNlRWZmZWN0IiwidXNlRGVidWdWYWx1ZSIsInVzZUNhbGxiYWNrIiwiZ2V0RGVmYXVsdFN0b3JlIiwiY3JlYXRlU3RvcmUiLCJTdG9yZUNvbnRleHQiLCJ1bmRlZmluZWQiLCJ1c2VTdG9yZSIsIm9wdGlvbnMiLCJzdG9yZSIsIlByb3ZpZGVyIiwiY2hpbGRyZW4iLCJzdG9yZVJlZiIsImN1cnJlbnQiLCJ2YWx1ZSIsImlzUHJvbWlzZUxpa2UiLCJ4IiwidGhlbiIsImF0dGFjaFByb21pc2VNZXRhIiwicHJvbWlzZSIsInN0YXR1cyIsInYiLCJlIiwicmVhc29uIiwidXNlIiwiY29udGludWFibGVQcm9taXNlTWFwIiwiV2Vha01hcCIsImNyZWF0ZUNvbnRpbnVhYmxlUHJvbWlzZSIsImNvbnRpbnVhYmxlUHJvbWlzZSIsImdldCIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwiY3VyciIsIm9uRnVsZmlsbGVkIiwibWUiLCJvblJlamVjdGVkIiwicmVnaXN0ZXJDYW5jZWxIYW5kbGVyIiwicCIsIm9uQ2FuY2VsIiwibmV4dFZhbHVlIiwiZW52IiwiTU9ERSIsIkVycm9yIiwic2V0IiwidXNlQXRvbVZhbHVlIiwiYXRvbSIsInZhbHVlRnJvbVJlZHVjZXIiLCJzdG9yZUZyb21SZWR1Y2VyIiwiYXRvbUZyb21SZWR1Y2VyIiwicmVyZW5kZXIiLCJwcmV2IiwiT2JqZWN0IiwiaXMiLCJkZWxheSIsInVuc3ViIiwic3ViIiwidmFsdWUyIiwic2V0VGltZW91dCIsInVzZVNldEF0b20iLCJzZXRBdG9tIiwiYXJncyIsInVzZUF0b20iXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/react.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/jotai/esm/vanilla.mjs":
/*!********************************************!*\
  !*** ./node_modules/jotai/esm/vanilla.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   atom: () => (/* binding */ atom),\n/* harmony export */   createStore: () => (/* binding */ createStore),\n/* harmony export */   getDefaultStore: () => (/* binding */ getDefaultStore)\n/* harmony export */ });\nlet keyCount = 0;\nfunction atom(read, write) {\n  const key = `atom${++keyCount}`;\n  const config = {\n    toString() {\n      return  true && this.debugLabel ? key + \":\" + this.debugLabel : key;\n    }\n  };\n  if (typeof read === \"function\") {\n    config.read = read;\n  } else {\n    config.init = read;\n    config.read = defaultRead;\n    config.write = defaultWrite;\n  }\n  if (write) {\n    config.write = write;\n  }\n  return config;\n}\nfunction defaultRead(get) {\n  return get(this);\n}\nfunction defaultWrite(get, set, arg) {\n  return set(\n    this,\n    typeof arg === \"function\" ? arg(get(this)) : arg\n  );\n}\n\nconst isSelfAtom = (atom, a) => atom.unstable_is ? atom.unstable_is(a) : a === atom;\nconst hasInitialValue = (atom) => \"init\" in atom;\nconst isActuallyWritableAtom = (atom) => !!atom.write;\nconst cancelablePromiseMap = /* @__PURE__ */ new WeakMap();\nconst isPendingPromise = (value) => {\n  var _a;\n  return isPromiseLike(value) && !((_a = cancelablePromiseMap.get(value)) == null ? undefined : _a[1]);\n};\nconst cancelPromise = (promise, nextValue) => {\n  const promiseState = cancelablePromiseMap.get(promise);\n  if (promiseState) {\n    promiseState[1] = true;\n    promiseState[0].forEach((fn) => fn(nextValue));\n  } else if (true) {\n    throw new Error(\"[Bug] cancelable promise not found\");\n  }\n};\nconst patchPromiseForCancelability = (promise) => {\n  if (cancelablePromiseMap.has(promise)) {\n    return;\n  }\n  const promiseState = [/* @__PURE__ */ new Set(), false];\n  cancelablePromiseMap.set(promise, promiseState);\n  const settle = () => {\n    promiseState[1] = true;\n  };\n  promise.then(settle, settle);\n  promise.onCancel = (fn) => {\n    promiseState[0].add(fn);\n  };\n};\nconst isPromiseLike = (p) => typeof (p == null ? undefined : p.then) === \"function\";\nconst isAtomStateInitialized = (atomState) => \"v\" in atomState || \"e\" in atomState;\nconst returnAtomValue = (atomState) => {\n  if (\"e\" in atomState) {\n    throw atomState.e;\n  }\n  if ( true && !(\"v\" in atomState)) {\n    throw new Error(\"[Bug] atom state is not initialized\");\n  }\n  return atomState.v;\n};\nconst addPendingPromiseToDependency = (atom, promise, dependencyAtomState) => {\n  if (!dependencyAtomState.p.has(atom)) {\n    dependencyAtomState.p.add(atom);\n    promise.then(\n      () => {\n        dependencyAtomState.p.delete(atom);\n      },\n      () => {\n        dependencyAtomState.p.delete(atom);\n      }\n    );\n  }\n};\nconst addDependency = (atom, atomState, a, aState) => {\n  var _a;\n  if ( true && a === atom) {\n    throw new Error(\"[Bug] atom cannot depend on itself\");\n  }\n  atomState.d.set(a, aState.n);\n  if (isPendingPromise(atomState.v)) {\n    addPendingPromiseToDependency(atom, atomState.v, aState);\n  }\n  (_a = aState.m) == null ? undefined : _a.t.add(atom);\n};\nconst INTERNAL_flushStoreHook = Symbol.for(\"JOTAI.EXPERIMENTAL.FLUSHSTOREHOOK\");\nconst buildStore = (...storeArgs) => {\n  const [\n    getAtomState,\n    setAtomState,\n    atomRead,\n    atomWrite,\n    atomOnInit,\n    atomOnMount\n  ] = storeArgs;\n  const ensureAtomState = (atom) => {\n    if ( true && !atom) {\n      throw new Error(\"Atom is undefined or null\");\n    }\n    let atomState = getAtomState(atom);\n    if (!atomState) {\n      atomState = { d: /* @__PURE__ */ new Map(), p: /* @__PURE__ */ new Set(), n: 0 };\n      setAtomState(atom, atomState);\n      atomOnInit == null ? undefined : atomOnInit(atom, store);\n    }\n    return atomState;\n  };\n  const invalidatedAtoms = /* @__PURE__ */ new WeakMap();\n  const changedAtoms = /* @__PURE__ */ new Map();\n  const unmountCallbacks = /* @__PURE__ */ new Set();\n  const mountCallbacks = /* @__PURE__ */ new Set();\n  const flushCallbacks = () => {\n    var _a;\n    const errors = [];\n    const call = (fn) => {\n      try {\n        fn();\n      } catch (e) {\n        errors.push(e);\n      }\n    };\n    do {\n      (_a = store[INTERNAL_flushStoreHook]) == null ? undefined : _a.call(store);\n      const callbacks = /* @__PURE__ */ new Set();\n      const add = callbacks.add.bind(callbacks);\n      changedAtoms.forEach((atomState) => {\n        var _a2;\n        return (_a2 = atomState.m) == null ? undefined : _a2.l.forEach(add);\n      });\n      changedAtoms.clear();\n      unmountCallbacks.forEach(add);\n      unmountCallbacks.clear();\n      mountCallbacks.forEach(add);\n      mountCallbacks.clear();\n      callbacks.forEach(call);\n      if (changedAtoms.size) {\n        recomputeInvalidatedAtoms();\n      }\n    } while (changedAtoms.size || unmountCallbacks.size || mountCallbacks.size);\n    if (errors.length) {\n      throw errors[0];\n    }\n  };\n  const setAtomStateValueOrPromise = (atom, atomState, valueOrPromise) => {\n    const hasPrevValue = \"v\" in atomState;\n    const prevValue = atomState.v;\n    const pendingPromise = isPendingPromise(atomState.v) ? atomState.v : null;\n    if (isPromiseLike(valueOrPromise)) {\n      patchPromiseForCancelability(valueOrPromise);\n      for (const a of atomState.d.keys()) {\n        addPendingPromiseToDependency(atom, valueOrPromise, ensureAtomState(a));\n      }\n      atomState.v = valueOrPromise;\n    } else {\n      atomState.v = valueOrPromise;\n    }\n    delete atomState.e;\n    if (!hasPrevValue || !Object.is(prevValue, atomState.v)) {\n      ++atomState.n;\n      if (pendingPromise) {\n        cancelPromise(pendingPromise, valueOrPromise);\n      }\n    }\n  };\n  const readAtomState = (atom) => {\n    var _a;\n    const atomState = ensureAtomState(atom);\n    if (isAtomStateInitialized(atomState)) {\n      if (atomState.m && invalidatedAtoms.get(atom) !== atomState.n) {\n        return atomState;\n      }\n      if (Array.from(atomState.d).every(\n        ([a, n]) => (\n          // Recursively, read the atom state of the dependency, and\n          // check if the atom epoch number is unchanged\n          readAtomState(a).n === n\n        )\n      )) {\n        return atomState;\n      }\n    }\n    atomState.d.clear();\n    let isSync = true;\n    const mountDependenciesIfAsync = () => {\n      if (atomState.m) {\n        mountDependencies(atom, atomState);\n        recomputeInvalidatedAtoms();\n        flushCallbacks();\n      }\n    };\n    const getter = (a) => {\n      if (isSelfAtom(atom, a)) {\n        const aState2 = ensureAtomState(a);\n        if (!isAtomStateInitialized(aState2)) {\n          if (hasInitialValue(a)) {\n            setAtomStateValueOrPromise(a, aState2, a.init);\n          } else {\n            throw new Error(\"no atom init\");\n          }\n        }\n        return returnAtomValue(aState2);\n      }\n      const aState = readAtomState(a);\n      try {\n        return returnAtomValue(aState);\n      } finally {\n        addDependency(atom, atomState, a, aState);\n        if (!isSync) {\n          mountDependenciesIfAsync();\n        }\n      }\n    };\n    let controller;\n    let setSelf;\n    const options = {\n      get signal() {\n        if (!controller) {\n          controller = new AbortController();\n        }\n        return controller.signal;\n      },\n      get setSelf() {\n        if ( true && !isActuallyWritableAtom(atom)) {\n          console.warn(\"setSelf function cannot be used with read-only atom\");\n        }\n        if (!setSelf && isActuallyWritableAtom(atom)) {\n          setSelf = (...args) => {\n            if ( true && isSync) {\n              console.warn(\"setSelf function cannot be called in sync\");\n            }\n            if (!isSync) {\n              return writeAtom(atom, ...args);\n            }\n          };\n        }\n        return setSelf;\n      }\n    };\n    try {\n      const valueOrPromise = atomRead(atom, getter, options);\n      setAtomStateValueOrPromise(atom, atomState, valueOrPromise);\n      if (isPromiseLike(valueOrPromise)) {\n        (_a = valueOrPromise.onCancel) == null ? void 0 : _a.call(valueOrPromise, () => controller == null ? void 0 : controller.abort());\n        valueOrPromise.then(mountDependenciesIfAsync, mountDependenciesIfAsync);\n      }\n      return atomState;\n    } catch (error) {\n      delete atomState.v;\n      atomState.e = error;\n      ++atomState.n;\n      return atomState;\n    } finally {\n      isSync = false;\n    }\n  };\n  const readAtom = (atom) => returnAtomValue(readAtomState(atom));\n  const getMountedOrPendingDependents = (atomState) => {\n    var _a;\n    const dependents = /* @__PURE__ */ new Map();\n    for (const a of ((_a = atomState.m) == null ? undefined : _a.t) || []) {\n      const aState = ensureAtomState(a);\n      if (aState.m) {\n        dependents.set(a, aState);\n      }\n    }\n    for (const atomWithPendingPromise of atomState.p) {\n      dependents.set(\n        atomWithPendingPromise,\n        ensureAtomState(atomWithPendingPromise)\n      );\n    }\n    return dependents;\n  };\n  const invalidateDependents = (atomState) => {\n    const stack = [atomState];\n    while (stack.length) {\n      const aState = stack.pop();\n      for (const [d, s] of getMountedOrPendingDependents(aState)) {\n        if (!invalidatedAtoms.has(d)) {\n          invalidatedAtoms.set(d, s.n);\n          stack.push(s);\n        }\n      }\n    }\n  };\n  const recomputeInvalidatedAtoms = () => {\n    var _a;\n    const topSortedReversed = [];\n    const visiting = /* @__PURE__ */ new WeakSet();\n    const visited = /* @__PURE__ */ new WeakSet();\n    const stack = Array.from(changedAtoms);\n    while (stack.length) {\n      const [a, aState] = stack[stack.length - 1];\n      if (visited.has(a)) {\n        stack.pop();\n        continue;\n      }\n      if (visiting.has(a)) {\n        if (invalidatedAtoms.get(a) === aState.n) {\n          topSortedReversed.push([a, aState, aState.n]);\n        } else {\n          invalidatedAtoms.delete(a);\n          changedAtoms.set(a, aState);\n        }\n        visited.add(a);\n        stack.pop();\n        continue;\n      }\n      visiting.add(a);\n      for (const [d, s] of getMountedOrPendingDependents(aState)) {\n        if (!visiting.has(d)) {\n          stack.push([d, s]);\n        }\n      }\n    }\n    for (let i = topSortedReversed.length - 1; i >= 0; --i) {\n      const [a, aState, prevEpochNumber] = topSortedReversed[i];\n      let hasChangedDeps = false;\n      for (const dep of aState.d.keys()) {\n        if (dep !== a && changedAtoms.has(dep)) {\n          hasChangedDeps = true;\n          break;\n        }\n      }\n      if (hasChangedDeps) {\n        readAtomState(a);\n        mountDependencies(a, aState);\n        if (prevEpochNumber !== aState.n) {\n          changedAtoms.set(a, aState);\n          (_a = aState.u) == null ? undefined : _a.call(aState);\n        }\n      }\n      invalidatedAtoms.delete(a);\n    }\n  };\n  const writeAtomState = (atom, ...args) => {\n    let isSync = true;\n    const getter = (a) => returnAtomValue(readAtomState(a));\n    const setter = (a, ...args2) => {\n      var _a;\n      const aState = ensureAtomState(a);\n      try {\n        if (isSelfAtom(atom, a)) {\n          if (!hasInitialValue(a)) {\n            throw new Error(\"atom not writable\");\n          }\n          const prevEpochNumber = aState.n;\n          const v = args2[0];\n          setAtomStateValueOrPromise(a, aState, v);\n          mountDependencies(a, aState);\n          if (prevEpochNumber !== aState.n) {\n            changedAtoms.set(a, aState);\n            (_a = aState.u) == null ? void 0 : _a.call(aState);\n            invalidateDependents(aState);\n          }\n          return void 0;\n        } else {\n          return writeAtomState(a, ...args2);\n        }\n      } finally {\n        if (!isSync) {\n          recomputeInvalidatedAtoms();\n          flushCallbacks();\n        }\n      }\n    };\n    try {\n      return atomWrite(atom, getter, setter, ...args);\n    } finally {\n      isSync = false;\n    }\n  };\n  const writeAtom = (atom, ...args) => {\n    try {\n      return writeAtomState(atom, ...args);\n    } finally {\n      recomputeInvalidatedAtoms();\n      flushCallbacks();\n    }\n  };\n  const mountDependencies = (atom, atomState) => {\n    var _a;\n    if (atomState.m && !isPendingPromise(atomState.v)) {\n      for (const [a, n] of atomState.d) {\n        if (!atomState.m.d.has(a)) {\n          const aState = ensureAtomState(a);\n          const aMounted = mountAtom(a, aState);\n          aMounted.t.add(atom);\n          atomState.m.d.add(a);\n          if (n !== aState.n) {\n            changedAtoms.set(a, aState);\n            (_a = aState.u) == null ? undefined : _a.call(aState);\n            invalidateDependents(aState);\n          }\n        }\n      }\n      for (const a of atomState.m.d || []) {\n        if (!atomState.d.has(a)) {\n          atomState.m.d.delete(a);\n          const aMounted = unmountAtom(a, ensureAtomState(a));\n          aMounted == null ? undefined : aMounted.t.delete(atom);\n        }\n      }\n    }\n  };\n  const mountAtom = (atom, atomState) => {\n    var _a;\n    if (!atomState.m) {\n      readAtomState(atom);\n      for (const a of atomState.d.keys()) {\n        const aMounted = mountAtom(a, ensureAtomState(a));\n        aMounted.t.add(atom);\n      }\n      atomState.m = {\n        l: /* @__PURE__ */ new Set(),\n        d: new Set(atomState.d.keys()),\n        t: /* @__PURE__ */ new Set()\n      };\n      (_a = atomState.h) == null ? undefined : _a.call(atomState);\n      if (isActuallyWritableAtom(atom)) {\n        const mounted = atomState.m;\n        const processOnMount = () => {\n          let isSync = true;\n          const setAtom = (...args) => {\n            try {\n              return writeAtomState(atom, ...args);\n            } finally {\n              if (!isSync) {\n                recomputeInvalidatedAtoms();\n                flushCallbacks();\n              }\n            }\n          };\n          try {\n            const onUnmount = atomOnMount(atom, setAtom);\n            if (onUnmount) {\n              mounted.u = () => {\n                isSync = true;\n                try {\n                  onUnmount();\n                } finally {\n                  isSync = false;\n                }\n              };\n            }\n          } finally {\n            isSync = false;\n          }\n        };\n        mountCallbacks.add(processOnMount);\n      }\n    }\n    return atomState.m;\n  };\n  const unmountAtom = (atom, atomState) => {\n    var _a;\n    if (atomState.m && !atomState.m.l.size && !Array.from(atomState.m.t).some((a) => {\n      var _a2;\n      return (_a2 = ensureAtomState(a).m) == null ? undefined : _a2.d.has(atom);\n    })) {\n      const onUnmount = atomState.m.u;\n      if (onUnmount) {\n        unmountCallbacks.add(onUnmount);\n      }\n      delete atomState.m;\n      (_a = atomState.h) == null ? undefined : _a.call(atomState);\n      for (const a of atomState.d.keys()) {\n        const aMounted = unmountAtom(a, ensureAtomState(a));\n        aMounted == null ? undefined : aMounted.t.delete(atom);\n      }\n      return undefined;\n    }\n    return atomState.m;\n  };\n  const subscribeAtom = (atom, listener) => {\n    const atomState = ensureAtomState(atom);\n    const mounted = mountAtom(atom, atomState);\n    const listeners = mounted.l;\n    listeners.add(listener);\n    flushCallbacks();\n    return () => {\n      listeners.delete(listener);\n      unmountAtom(atom, atomState);\n      flushCallbacks();\n    };\n  };\n  const unstable_derive = (fn) => buildStore(...fn(...storeArgs));\n  const store = {\n    get: readAtom,\n    set: writeAtom,\n    sub: subscribeAtom,\n    unstable_derive\n  };\n  return store;\n};\nconst deriveDevStoreRev4 = (store) => {\n  const debugMountedAtoms = /* @__PURE__ */ new Set();\n  let savedGetAtomState;\n  let inRestoreAtom = 0;\n  const derivedStore = store.unstable_derive((...storeArgs) => {\n    const [getAtomState, setAtomState, , atomWrite] = storeArgs;\n    savedGetAtomState = getAtomState;\n    storeArgs[1] = function devSetAtomState(atom, atomState) {\n      setAtomState(atom, atomState);\n      const originalMounted = atomState.h;\n      atomState.h = () => {\n        originalMounted == null ? undefined : originalMounted();\n        if (atomState.m) {\n          debugMountedAtoms.add(atom);\n        } else {\n          debugMountedAtoms.delete(atom);\n        }\n      };\n    };\n    storeArgs[3] = function devAtomWrite(atom, getter, setter, ...args) {\n      if (inRestoreAtom) {\n        return setter(atom, ...args);\n      }\n      return atomWrite(atom, getter, setter, ...args);\n    };\n    return storeArgs;\n  });\n  const savedStoreSet = derivedStore.set;\n  const devStore = {\n    // store dev methods (these are tentative and subject to change without notice)\n    dev4_get_internal_weak_map: () => ({\n      get: (atom) => {\n        const atomState = savedGetAtomState(atom);\n        if (!atomState || atomState.n === 0) {\n          return undefined;\n        }\n        return atomState;\n      }\n    }),\n    dev4_get_mounted_atoms: () => debugMountedAtoms,\n    dev4_restore_atoms: (values) => {\n      const restoreAtom = {\n        read: () => null,\n        write: (_get, set) => {\n          ++inRestoreAtom;\n          try {\n            for (const [atom, value] of values) {\n              if (hasInitialValue(atom)) {\n                set(atom, value);\n              }\n            }\n          } finally {\n            --inRestoreAtom;\n          }\n        }\n      };\n      savedStoreSet(restoreAtom);\n    }\n  };\n  return Object.assign(derivedStore, devStore);\n};\nconst createStore = () => {\n  const atomStateMap = /* @__PURE__ */ new WeakMap();\n  const store = buildStore(\n    (atom) => atomStateMap.get(atom),\n    (atom, atomState) => atomStateMap.set(atom, atomState).get(atom),\n    (atom, ...params) => atom.read(...params),\n    (atom, ...params) => atom.write(...params),\n    (atom, ...params) => {\n      var _a;\n      return (_a = atom.unstable_onInit) == null ? undefined : _a.call(atom, ...params);\n    },\n    (atom, ...params) => {\n      var _a;\n      return (_a = atom.onMount) == null ? undefined : _a.call(atom, ...params);\n    }\n  );\n  if (true) {\n    return deriveDevStoreRev4(store);\n  }\n  return store;\n};\nlet defaultStore;\nconst getDefaultStore = () => {\n  if (!defaultStore) {\n    defaultStore = createStore();\n    if (true) {\n      globalThis.__JOTAI_DEFAULT_STORE__ || (globalThis.__JOTAI_DEFAULT_STORE__ = defaultStore);\n      if (globalThis.__JOTAI_DEFAULT_STORE__ !== defaultStore) {\n        console.warn(\n          \"Detected multiple Jotai instances. It may cause unexpected behavior with the default store. https://github.com/pmndrs/jotai/discussions/2044\"\n        );\n      }\n    }\n  }\n  return defaultStore;\n};\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFBO0FBQ0E7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0EsYUFBYSxLQUFxRTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLFNBQVMsSUFBcUU7QUFDbEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU0sS0FBcUU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXFFO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsWUFBWSxLQUFxRTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFxRTtBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTSxJQUFxRTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxJQUFxRTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFOEMiLCJzb3VyY2VzIjpbIi9tbnQvYy9Vc2Vycy90YW5haC9naXQvSmF2YUxhbmdSdW50aW1lRXhjZXB0aW9uLmdpdGh1Yi5pby9ub2RlX21vZHVsZXMvam90YWkvZXNtL3ZhbmlsbGEubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImxldCBrZXlDb3VudCA9IDA7XG5mdW5jdGlvbiBhdG9tKHJlYWQsIHdyaXRlKSB7XG4gIGNvbnN0IGtleSA9IGBhdG9tJHsrK2tleUNvdW50fWA7XG4gIGNvbnN0IGNvbmZpZyA9IHtcbiAgICB0b1N0cmluZygpIHtcbiAgICAgIHJldHVybiAoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB1bmRlZmluZWQpICE9PSBcInByb2R1Y3Rpb25cIiAmJiB0aGlzLmRlYnVnTGFiZWwgPyBrZXkgKyBcIjpcIiArIHRoaXMuZGVidWdMYWJlbCA6IGtleTtcbiAgICB9XG4gIH07XG4gIGlmICh0eXBlb2YgcmVhZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgY29uZmlnLnJlYWQgPSByZWFkO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5pbml0ID0gcmVhZDtcbiAgICBjb25maWcucmVhZCA9IGRlZmF1bHRSZWFkO1xuICAgIGNvbmZpZy53cml0ZSA9IGRlZmF1bHRXcml0ZTtcbiAgfVxuICBpZiAod3JpdGUpIHtcbiAgICBjb25maWcud3JpdGUgPSB3cml0ZTtcbiAgfVxuICByZXR1cm4gY29uZmlnO1xufVxuZnVuY3Rpb24gZGVmYXVsdFJlYWQoZ2V0KSB7XG4gIHJldHVybiBnZXQodGhpcyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0V3JpdGUoZ2V0LCBzZXQsIGFyZykge1xuICByZXR1cm4gc2V0KFxuICAgIHRoaXMsXG4gICAgdHlwZW9mIGFyZyA9PT0gXCJmdW5jdGlvblwiID8gYXJnKGdldCh0aGlzKSkgOiBhcmdcbiAgKTtcbn1cblxuY29uc3QgaXNTZWxmQXRvbSA9IChhdG9tLCBhKSA9PiBhdG9tLnVuc3RhYmxlX2lzID8gYXRvbS51bnN0YWJsZV9pcyhhKSA6IGEgPT09IGF0b207XG5jb25zdCBoYXNJbml0aWFsVmFsdWUgPSAoYXRvbSkgPT4gXCJpbml0XCIgaW4gYXRvbTtcbmNvbnN0IGlzQWN0dWFsbHlXcml0YWJsZUF0b20gPSAoYXRvbSkgPT4gISFhdG9tLndyaXRlO1xuY29uc3QgY2FuY2VsYWJsZVByb21pc2VNYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGlzUGVuZGluZ1Byb21pc2UgPSAodmFsdWUpID0+IHtcbiAgdmFyIF9hO1xuICByZXR1cm4gaXNQcm9taXNlTGlrZSh2YWx1ZSkgJiYgISgoX2EgPSBjYW5jZWxhYmxlUHJvbWlzZU1hcC5nZXQodmFsdWUpKSA9PSBudWxsID8gdW5kZWZpbmVkIDogX2FbMV0pO1xufTtcbmNvbnN0IGNhbmNlbFByb21pc2UgPSAocHJvbWlzZSwgbmV4dFZhbHVlKSA9PiB7XG4gIGNvbnN0IHByb21pc2VTdGF0ZSA9IGNhbmNlbGFibGVQcm9taXNlTWFwLmdldChwcm9taXNlKTtcbiAgaWYgKHByb21pc2VTdGF0ZSkge1xuICAgIHByb21pc2VTdGF0ZVsxXSA9IHRydWU7XG4gICAgcHJvbWlzZVN0YXRlWzBdLmZvckVhY2goKGZuKSA9PiBmbihuZXh0VmFsdWUpKTtcbiAgfSBlbHNlIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB1bmRlZmluZWQpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHRocm93IG5ldyBFcnJvcihcIltCdWddIGNhbmNlbGFibGUgcHJvbWlzZSBub3QgZm91bmRcIik7XG4gIH1cbn07XG5jb25zdCBwYXRjaFByb21pc2VGb3JDYW5jZWxhYmlsaXR5ID0gKHByb21pc2UpID0+IHtcbiAgaWYgKGNhbmNlbGFibGVQcm9taXNlTWFwLmhhcyhwcm9taXNlKSkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBwcm9taXNlU3RhdGUgPSBbLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgZmFsc2VdO1xuICBjYW5jZWxhYmxlUHJvbWlzZU1hcC5zZXQocHJvbWlzZSwgcHJvbWlzZVN0YXRlKTtcbiAgY29uc3Qgc2V0dGxlID0gKCkgPT4ge1xuICAgIHByb21pc2VTdGF0ZVsxXSA9IHRydWU7XG4gIH07XG4gIHByb21pc2UudGhlbihzZXR0bGUsIHNldHRsZSk7XG4gIHByb21pc2Uub25DYW5jZWwgPSAoZm4pID0+IHtcbiAgICBwcm9taXNlU3RhdGVbMF0uYWRkKGZuKTtcbiAgfTtcbn07XG5jb25zdCBpc1Byb21pc2VMaWtlID0gKHApID0+IHR5cGVvZiAocCA9PSBudWxsID8gdW5kZWZpbmVkIDogcC50aGVuKSA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNBdG9tU3RhdGVJbml0aWFsaXplZCA9IChhdG9tU3RhdGUpID0+IFwidlwiIGluIGF0b21TdGF0ZSB8fCBcImVcIiBpbiBhdG9tU3RhdGU7XG5jb25zdCByZXR1cm5BdG9tVmFsdWUgPSAoYXRvbVN0YXRlKSA9PiB7XG4gIGlmIChcImVcIiBpbiBhdG9tU3RhdGUpIHtcbiAgICB0aHJvdyBhdG9tU3RhdGUuZTtcbiAgfVxuICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdW5kZWZpbmVkKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIShcInZcIiBpbiBhdG9tU3RhdGUpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiW0J1Z10gYXRvbSBzdGF0ZSBpcyBub3QgaW5pdGlhbGl6ZWRcIik7XG4gIH1cbiAgcmV0dXJuIGF0b21TdGF0ZS52O1xufTtcbmNvbnN0IGFkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5ID0gKGF0b20sIHByb21pc2UsIGRlcGVuZGVuY3lBdG9tU3RhdGUpID0+IHtcbiAgaWYgKCFkZXBlbmRlbmN5QXRvbVN0YXRlLnAuaGFzKGF0b20pKSB7XG4gICAgZGVwZW5kZW5jeUF0b21TdGF0ZS5wLmFkZChhdG9tKTtcbiAgICBwcm9taXNlLnRoZW4oXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGRlcGVuZGVuY3lBdG9tU3RhdGUucC5kZWxldGUoYXRvbSk7XG4gICAgICB9LFxuICAgICAgKCkgPT4ge1xuICAgICAgICBkZXBlbmRlbmN5QXRvbVN0YXRlLnAuZGVsZXRlKGF0b20pO1xuICAgICAgfVxuICAgICk7XG4gIH1cbn07XG5jb25zdCBhZGREZXBlbmRlbmN5ID0gKGF0b20sIGF0b21TdGF0ZSwgYSwgYVN0YXRlKSA9PiB7XG4gIHZhciBfYTtcbiAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHVuZGVmaW5lZCkgIT09IFwicHJvZHVjdGlvblwiICYmIGEgPT09IGF0b20pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJbQnVnXSBhdG9tIGNhbm5vdCBkZXBlbmQgb24gaXRzZWxmXCIpO1xuICB9XG4gIGF0b21TdGF0ZS5kLnNldChhLCBhU3RhdGUubik7XG4gIGlmIChpc1BlbmRpbmdQcm9taXNlKGF0b21TdGF0ZS52KSkge1xuICAgIGFkZFBlbmRpbmdQcm9taXNlVG9EZXBlbmRlbmN5KGF0b20sIGF0b21TdGF0ZS52LCBhU3RhdGUpO1xuICB9XG4gIChfYSA9IGFTdGF0ZS5tKSA9PSBudWxsID8gdW5kZWZpbmVkIDogX2EudC5hZGQoYXRvbSk7XG59O1xuY29uc3QgSU5URVJOQUxfZmx1c2hTdG9yZUhvb2sgPSBTeW1ib2wuZm9yKFwiSk9UQUkuRVhQRVJJTUVOVEFMLkZMVVNIU1RPUkVIT09LXCIpO1xuY29uc3QgYnVpbGRTdG9yZSA9ICguLi5zdG9yZUFyZ3MpID0+IHtcbiAgY29uc3QgW1xuICAgIGdldEF0b21TdGF0ZSxcbiAgICBzZXRBdG9tU3RhdGUsXG4gICAgYXRvbVJlYWQsXG4gICAgYXRvbVdyaXRlLFxuICAgIGF0b21PbkluaXQsXG4gICAgYXRvbU9uTW91bnRcbiAgXSA9IHN0b3JlQXJncztcbiAgY29uc3QgZW5zdXJlQXRvbVN0YXRlID0gKGF0b20pID0+IHtcbiAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdW5kZWZpbmVkKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWF0b20pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkF0b20gaXMgdW5kZWZpbmVkIG9yIG51bGxcIik7XG4gICAgfVxuICAgIGxldCBhdG9tU3RhdGUgPSBnZXRBdG9tU3RhdGUoYXRvbSk7XG4gICAgaWYgKCFhdG9tU3RhdGUpIHtcbiAgICAgIGF0b21TdGF0ZSA9IHsgZDogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSwgcDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSwgbjogMCB9O1xuICAgICAgc2V0QXRvbVN0YXRlKGF0b20sIGF0b21TdGF0ZSk7XG4gICAgICBhdG9tT25Jbml0ID09IG51bGwgPyB1bmRlZmluZWQgOiBhdG9tT25Jbml0KGF0b20sIHN0b3JlKTtcbiAgICB9XG4gICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgfTtcbiAgY29uc3QgaW52YWxpZGF0ZWRBdG9tcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBjaGFuZ2VkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICBjb25zdCB1bm1vdW50Q2FsbGJhY2tzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3QgbW91bnRDYWxsYmFja3MgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBmbHVzaENhbGxiYWNrcyA9ICgpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgY29uc3QgY2FsbCA9IChmbikgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZm4oKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgZXJyb3JzLnB1c2goZSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBkbyB7XG4gICAgICAoX2EgPSBzdG9yZVtJTlRFUk5BTF9mbHVzaFN0b3JlSG9va10pID09IG51bGwgPyB1bmRlZmluZWQgOiBfYS5jYWxsKHN0b3JlKTtcbiAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgICBjb25zdCBhZGQgPSBjYWxsYmFja3MuYWRkLmJpbmQoY2FsbGJhY2tzKTtcbiAgICAgIGNoYW5nZWRBdG9tcy5mb3JFYWNoKChhdG9tU3RhdGUpID0+IHtcbiAgICAgICAgdmFyIF9hMjtcbiAgICAgICAgcmV0dXJuIChfYTIgPSBhdG9tU3RhdGUubSkgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9hMi5sLmZvckVhY2goYWRkKTtcbiAgICAgIH0pO1xuICAgICAgY2hhbmdlZEF0b21zLmNsZWFyKCk7XG4gICAgICB1bm1vdW50Q2FsbGJhY2tzLmZvckVhY2goYWRkKTtcbiAgICAgIHVubW91bnRDYWxsYmFja3MuY2xlYXIoKTtcbiAgICAgIG1vdW50Q2FsbGJhY2tzLmZvckVhY2goYWRkKTtcbiAgICAgIG1vdW50Q2FsbGJhY2tzLmNsZWFyKCk7XG4gICAgICBjYWxsYmFja3MuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChjaGFuZ2VkQXRvbXMuc2l6ZSkge1xuICAgICAgICByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zKCk7XG4gICAgICB9XG4gICAgfSB3aGlsZSAoY2hhbmdlZEF0b21zLnNpemUgfHwgdW5tb3VudENhbGxiYWNrcy5zaXplIHx8IG1vdW50Q2FsbGJhY2tzLnNpemUpO1xuICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBlcnJvcnNbMF07XG4gICAgfVxuICB9O1xuICBjb25zdCBzZXRBdG9tU3RhdGVWYWx1ZU9yUHJvbWlzZSA9IChhdG9tLCBhdG9tU3RhdGUsIHZhbHVlT3JQcm9taXNlKSA9PiB7XG4gICAgY29uc3QgaGFzUHJldlZhbHVlID0gXCJ2XCIgaW4gYXRvbVN0YXRlO1xuICAgIGNvbnN0IHByZXZWYWx1ZSA9IGF0b21TdGF0ZS52O1xuICAgIGNvbnN0IHBlbmRpbmdQcm9taXNlID0gaXNQZW5kaW5nUHJvbWlzZShhdG9tU3RhdGUudikgPyBhdG9tU3RhdGUudiA6IG51bGw7XG4gICAgaWYgKGlzUHJvbWlzZUxpa2UodmFsdWVPclByb21pc2UpKSB7XG4gICAgICBwYXRjaFByb21pc2VGb3JDYW5jZWxhYmlsaXR5KHZhbHVlT3JQcm9taXNlKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgYWRkUGVuZGluZ1Byb21pc2VUb0RlcGVuZGVuY3koYXRvbSwgdmFsdWVPclByb21pc2UsIGVuc3VyZUF0b21TdGF0ZShhKSk7XG4gICAgICB9XG4gICAgICBhdG9tU3RhdGUudiA9IHZhbHVlT3JQcm9taXNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdG9tU3RhdGUudiA9IHZhbHVlT3JQcm9taXNlO1xuICAgIH1cbiAgICBkZWxldGUgYXRvbVN0YXRlLmU7XG4gICAgaWYgKCFoYXNQcmV2VmFsdWUgfHwgIU9iamVjdC5pcyhwcmV2VmFsdWUsIGF0b21TdGF0ZS52KSkge1xuICAgICAgKythdG9tU3RhdGUubjtcbiAgICAgIGlmIChwZW5kaW5nUHJvbWlzZSkge1xuICAgICAgICBjYW5jZWxQcm9taXNlKHBlbmRpbmdQcm9taXNlLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbVN0YXRlID0gKGF0b20pID0+IHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgYXRvbVN0YXRlID0gZW5zdXJlQXRvbVN0YXRlKGF0b20pO1xuICAgIGlmIChpc0F0b21TdGF0ZUluaXRpYWxpemVkKGF0b21TdGF0ZSkpIHtcbiAgICAgIGlmIChhdG9tU3RhdGUubSAmJiBpbnZhbGlkYXRlZEF0b21zLmdldChhdG9tKSAhPT0gYXRvbVN0YXRlLm4pIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICAgIGlmIChBcnJheS5mcm9tKGF0b21TdGF0ZS5kKS5ldmVyeShcbiAgICAgICAgKFthLCBuXSkgPT4gKFxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5LCByZWFkIHRoZSBhdG9tIHN0YXRlIG9mIHRoZSBkZXBlbmRlbmN5LCBhbmRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgYXRvbSBlcG9jaCBudW1iZXIgaXMgdW5jaGFuZ2VkXG4gICAgICAgICAgcmVhZEF0b21TdGF0ZShhKS5uID09PSBuXG4gICAgICAgIClcbiAgICAgICkpIHtcbiAgICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXRvbVN0YXRlLmQuY2xlYXIoKTtcbiAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICBjb25zdCBtb3VudERlcGVuZGVuY2llc0lmQXN5bmMgPSAoKSA9PiB7XG4gICAgICBpZiAoYXRvbVN0YXRlLm0pIHtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgICBmbHVzaENhbGxiYWNrcygpO1xuICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZ2V0dGVyID0gKGEpID0+IHtcbiAgICAgIGlmIChpc1NlbGZBdG9tKGF0b20sIGEpKSB7XG4gICAgICAgIGNvbnN0IGFTdGF0ZTIgPSBlbnN1cmVBdG9tU3RhdGUoYSk7XG4gICAgICAgIGlmICghaXNBdG9tU3RhdGVJbml0aWFsaXplZChhU3RhdGUyKSkge1xuICAgICAgICAgIGlmIChoYXNJbml0aWFsVmFsdWUoYSkpIHtcbiAgICAgICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGEsIGFTdGF0ZTIsIGEuaW5pdCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm5vIGF0b20gaW5pdFwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldHVybkF0b21WYWx1ZShhU3RhdGUyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFTdGF0ZSA9IHJlYWRBdG9tU3RhdGUoYSk7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmV0dXJuQXRvbVZhbHVlKGFTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBhZGREZXBlbmRlbmN5KGF0b20sIGF0b21TdGF0ZSwgYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKCFpc1N5bmMpIHtcbiAgICAgICAgICBtb3VudERlcGVuZGVuY2llc0lmQXN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgbGV0IGNvbnRyb2xsZXI7XG4gICAgbGV0IHNldFNlbGY7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgIGdldCBzaWduYWwoKSB7XG4gICAgICAgIGlmICghY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgICAgfSxcbiAgICAgIGdldCBzZXRTZWxmKCkge1xuICAgICAgICBpZiAoKGltcG9ydC5tZXRhLmVudiA/IGltcG9ydC5tZXRhLmVudi5NT0RFIDogdW5kZWZpbmVkKSAhPT0gXCJwcm9kdWN0aW9uXCIgJiYgIWlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXCJzZXRTZWxmIGZ1bmN0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggcmVhZC1vbmx5IGF0b21cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFzZXRTZWxmICYmIGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgICBzZXRTZWxmID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB1bmRlZmluZWQpICE9PSBcInByb2R1Y3Rpb25cIiAmJiBpc1N5bmMpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFwic2V0U2VsZiBmdW5jdGlvbiBjYW5ub3QgYmUgY2FsbGVkIGluIHN5bmNcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWlzU3luYykge1xuICAgICAgICAgICAgICByZXR1cm4gd3JpdGVBdG9tKGF0b20sIC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNldFNlbGY7XG4gICAgICB9XG4gICAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgdmFsdWVPclByb21pc2UgPSBhdG9tUmVhZChhdG9tLCBnZXR0ZXIsIG9wdGlvbnMpO1xuICAgICAgc2V0QXRvbVN0YXRlVmFsdWVPclByb21pc2UoYXRvbSwgYXRvbVN0YXRlLCB2YWx1ZU9yUHJvbWlzZSk7XG4gICAgICBpZiAoaXNQcm9taXNlTGlrZSh2YWx1ZU9yUHJvbWlzZSkpIHtcbiAgICAgICAgKF9hID0gdmFsdWVPclByb21pc2Uub25DYW5jZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKHZhbHVlT3JQcm9taXNlLCAoKSA9PiBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmFib3J0KCkpO1xuICAgICAgICB2YWx1ZU9yUHJvbWlzZS50aGVuKG1vdW50RGVwZW5kZW5jaWVzSWZBc3luYywgbW91bnREZXBlbmRlbmNpZXNJZkFzeW5jKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGRlbGV0ZSBhdG9tU3RhdGUudjtcbiAgICAgIGF0b21TdGF0ZS5lID0gZXJyb3I7XG4gICAgICArK2F0b21TdGF0ZS5uO1xuICAgICAgcmV0dXJuIGF0b21TdGF0ZTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCByZWFkQXRvbSA9IChhdG9tKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhdG9tKSk7XG4gIGNvbnN0IGdldE1vdW50ZWRPclBlbmRpbmdEZXBlbmRlbnRzID0gKGF0b21TdGF0ZSkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCBkZXBlbmRlbnRzID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGEgb2YgKChfYSA9IGF0b21TdGF0ZS5tKSA9PSBudWxsID8gdW5kZWZpbmVkIDogX2EudCkgfHwgW10pIHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhKTtcbiAgICAgIGlmIChhU3RhdGUubSkge1xuICAgICAgICBkZXBlbmRlbnRzLnNldChhLCBhU3RhdGUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGF0b21XaXRoUGVuZGluZ1Byb21pc2Ugb2YgYXRvbVN0YXRlLnApIHtcbiAgICAgIGRlcGVuZGVudHMuc2V0KFxuICAgICAgICBhdG9tV2l0aFBlbmRpbmdQcm9taXNlLFxuICAgICAgICBlbnN1cmVBdG9tU3RhdGUoYXRvbVdpdGhQZW5kaW5nUHJvbWlzZSlcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZXBlbmRlbnRzO1xuICB9O1xuICBjb25zdCBpbnZhbGlkYXRlRGVwZW5kZW50cyA9IChhdG9tU3RhdGUpID0+IHtcbiAgICBjb25zdCBzdGFjayA9IFthdG9tU3RhdGVdO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGFTdGF0ZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgZm9yIChjb25zdCBbZCwgc10gb2YgZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMoYVN0YXRlKSkge1xuICAgICAgICBpZiAoIWludmFsaWRhdGVkQXRvbXMuaGFzKGQpKSB7XG4gICAgICAgICAgaW52YWxpZGF0ZWRBdG9tcy5zZXQoZCwgcy5uKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCByZWNvbXB1dGVJbnZhbGlkYXRlZEF0b21zID0gKCkgPT4ge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB0b3BTb3J0ZWRSZXZlcnNlZCA9IFtdO1xuICAgIGNvbnN0IHZpc2l0aW5nID0gLyogQF9fUFVSRV9fICovIG5ldyBXZWFrU2V0KCk7XG4gICAgY29uc3QgdmlzaXRlZCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha1NldCgpO1xuICAgIGNvbnN0IHN0YWNrID0gQXJyYXkuZnJvbShjaGFuZ2VkQXRvbXMpO1xuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IFthLCBhU3RhdGVdID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBpZiAodmlzaXRlZC5oYXMoYSkpIHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHZpc2l0aW5nLmhhcyhhKSkge1xuICAgICAgICBpZiAoaW52YWxpZGF0ZWRBdG9tcy5nZXQoYSkgPT09IGFTdGF0ZS5uKSB7XG4gICAgICAgICAgdG9wU29ydGVkUmV2ZXJzZWQucHVzaChbYSwgYVN0YXRlLCBhU3RhdGUubl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGludmFsaWRhdGVkQXRvbXMuZGVsZXRlKGEpO1xuICAgICAgICAgIGNoYW5nZWRBdG9tcy5zZXQoYSwgYVN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICB2aXNpdGVkLmFkZChhKTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmlzaXRpbmcuYWRkKGEpO1xuICAgICAgZm9yIChjb25zdCBbZCwgc10gb2YgZ2V0TW91bnRlZE9yUGVuZGluZ0RlcGVuZGVudHMoYVN0YXRlKSkge1xuICAgICAgICBpZiAoIXZpc2l0aW5nLmhhcyhkKSkge1xuICAgICAgICAgIHN0YWNrLnB1c2goW2QsIHNdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBpID0gdG9wU29ydGVkUmV2ZXJzZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIGNvbnN0IFthLCBhU3RhdGUsIHByZXZFcG9jaE51bWJlcl0gPSB0b3BTb3J0ZWRSZXZlcnNlZFtpXTtcbiAgICAgIGxldCBoYXNDaGFuZ2VkRGVwcyA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBkZXAgb2YgYVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGlmIChkZXAgIT09IGEgJiYgY2hhbmdlZEF0b21zLmhhcyhkZXApKSB7XG4gICAgICAgICAgaGFzQ2hhbmdlZERlcHMgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoaGFzQ2hhbmdlZERlcHMpIHtcbiAgICAgICAgcmVhZEF0b21TdGF0ZShhKTtcbiAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYSwgYVN0YXRlKTtcbiAgICAgICAgaWYgKHByZXZFcG9jaE51bWJlciAhPT0gYVN0YXRlLm4pIHtcbiAgICAgICAgICBjaGFuZ2VkQXRvbXMuc2V0KGEsIGFTdGF0ZSk7XG4gICAgICAgICAgKF9hID0gYVN0YXRlLnUpID09IG51bGwgPyB1bmRlZmluZWQgOiBfYS5jYWxsKGFTdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGludmFsaWRhdGVkQXRvbXMuZGVsZXRlKGEpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgd3JpdGVBdG9tU3RhdGUgPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIGxldCBpc1N5bmMgPSB0cnVlO1xuICAgIGNvbnN0IGdldHRlciA9IChhKSA9PiByZXR1cm5BdG9tVmFsdWUocmVhZEF0b21TdGF0ZShhKSk7XG4gICAgY29uc3Qgc2V0dGVyID0gKGEsIC4uLmFyZ3MyKSA9PiB7XG4gICAgICB2YXIgX2E7XG4gICAgICBjb25zdCBhU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYSk7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoaXNTZWxmQXRvbShhdG9tLCBhKSkge1xuICAgICAgICAgIGlmICghaGFzSW5pdGlhbFZhbHVlKGEpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhdG9tIG5vdCB3cml0YWJsZVwiKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgcHJldkVwb2NoTnVtYmVyID0gYVN0YXRlLm47XG4gICAgICAgICAgY29uc3QgdiA9IGFyZ3MyWzBdO1xuICAgICAgICAgIHNldEF0b21TdGF0ZVZhbHVlT3JQcm9taXNlKGEsIGFTdGF0ZSwgdik7XG4gICAgICAgICAgbW91bnREZXBlbmRlbmNpZXMoYSwgYVN0YXRlKTtcbiAgICAgICAgICBpZiAocHJldkVwb2NoTnVtYmVyICE9PSBhU3RhdGUubikge1xuICAgICAgICAgICAgY2hhbmdlZEF0b21zLnNldChhLCBhU3RhdGUpO1xuICAgICAgICAgICAgKF9hID0gYVN0YXRlLnUpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGFTdGF0ZSk7XG4gICAgICAgICAgICBpbnZhbGlkYXRlRGVwZW5kZW50cyhhU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdm9pZCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB3cml0ZUF0b21TdGF0ZShhLCAuLi5hcmdzMik7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgICAgIGZsdXNoQ2FsbGJhY2tzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXRvbVdyaXRlKGF0b20sIGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaXNTeW5jID0gZmFsc2U7XG4gICAgfVxuICB9O1xuICBjb25zdCB3cml0ZUF0b20gPSAoYXRvbSwgLi4uYXJncykgPT4ge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gd3JpdGVBdG9tU3RhdGUoYXRvbSwgLi4uYXJncyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29tcHV0ZUludmFsaWRhdGVkQXRvbXMoKTtcbiAgICAgIGZsdXNoQ2FsbGJhY2tzKCk7XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudERlcGVuZGVuY2llcyA9IChhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGF0b21TdGF0ZS5tICYmICFpc1BlbmRpbmdQcm9taXNlKGF0b21TdGF0ZS52KSkge1xuICAgICAgZm9yIChjb25zdCBbYSwgbl0gb2YgYXRvbVN0YXRlLmQpIHtcbiAgICAgICAgaWYgKCFhdG9tU3RhdGUubS5kLmhhcyhhKSkge1xuICAgICAgICAgIGNvbnN0IGFTdGF0ZSA9IGVuc3VyZUF0b21TdGF0ZShhKTtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IG1vdW50QXRvbShhLCBhU3RhdGUpO1xuICAgICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgICAgIGF0b21TdGF0ZS5tLmQuYWRkKGEpO1xuICAgICAgICAgIGlmIChuICE9PSBhU3RhdGUubikge1xuICAgICAgICAgICAgY2hhbmdlZEF0b21zLnNldChhLCBhU3RhdGUpO1xuICAgICAgICAgICAgKF9hID0gYVN0YXRlLnUpID09IG51bGwgPyB1bmRlZmluZWQgOiBfYS5jYWxsKGFTdGF0ZSk7XG4gICAgICAgICAgICBpbnZhbGlkYXRlRGVwZW5kZW50cyhhU3RhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBhIG9mIGF0b21TdGF0ZS5tLmQgfHwgW10pIHtcbiAgICAgICAgaWYgKCFhdG9tU3RhdGUuZC5oYXMoYSkpIHtcbiAgICAgICAgICBhdG9tU3RhdGUubS5kLmRlbGV0ZShhKTtcbiAgICAgICAgICBjb25zdCBhTW91bnRlZCA9IHVubW91bnRBdG9tKGEsIGVuc3VyZUF0b21TdGF0ZShhKSk7XG4gICAgICAgICAgYU1vdW50ZWQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGFNb3VudGVkLnQuZGVsZXRlKGF0b20pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBjb25zdCBtb3VudEF0b20gPSAoYXRvbSwgYXRvbVN0YXRlKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIGlmICghYXRvbVN0YXRlLm0pIHtcbiAgICAgIHJlYWRBdG9tU3RhdGUoYXRvbSk7XG4gICAgICBmb3IgKGNvbnN0IGEgb2YgYXRvbVN0YXRlLmQua2V5cygpKSB7XG4gICAgICAgIGNvbnN0IGFNb3VudGVkID0gbW91bnRBdG9tKGEsIGVuc3VyZUF0b21TdGF0ZShhKSk7XG4gICAgICAgIGFNb3VudGVkLnQuYWRkKGF0b20pO1xuICAgICAgfVxuICAgICAgYXRvbVN0YXRlLm0gPSB7XG4gICAgICAgIGw6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCksXG4gICAgICAgIGQ6IG5ldyBTZXQoYXRvbVN0YXRlLmQua2V5cygpKSxcbiAgICAgICAgdDogLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKVxuICAgICAgfTtcbiAgICAgIChfYSA9IGF0b21TdGF0ZS5oKSA9PSBudWxsID8gdW5kZWZpbmVkIDogX2EuY2FsbChhdG9tU3RhdGUpO1xuICAgICAgaWYgKGlzQWN0dWFsbHlXcml0YWJsZUF0b20oYXRvbSkpIHtcbiAgICAgICAgY29uc3QgbW91bnRlZCA9IGF0b21TdGF0ZS5tO1xuICAgICAgICBjb25zdCBwcm9jZXNzT25Nb3VudCA9ICgpID0+IHtcbiAgICAgICAgICBsZXQgaXNTeW5jID0gdHJ1ZTtcbiAgICAgICAgICBjb25zdCBzZXRBdG9tID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJldHVybiB3cml0ZUF0b21TdGF0ZShhdG9tLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgIGlmICghaXNTeW5jKSB7XG4gICAgICAgICAgICAgICAgcmVjb21wdXRlSW52YWxpZGF0ZWRBdG9tcygpO1xuICAgICAgICAgICAgICAgIGZsdXNoQ2FsbGJhY2tzKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvblVubW91bnQgPSBhdG9tT25Nb3VudChhdG9tLCBzZXRBdG9tKTtcbiAgICAgICAgICAgIGlmIChvblVubW91bnQpIHtcbiAgICAgICAgICAgICAgbW91bnRlZC51ID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgIG9uVW5tb3VudCgpO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICBpc1N5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGlzU3luYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbW91bnRDYWxsYmFja3MuYWRkKHByb2Nlc3NPbk1vdW50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGF0b21TdGF0ZS5tO1xuICB9O1xuICBjb25zdCB1bm1vdW50QXRvbSA9IChhdG9tLCBhdG9tU3RhdGUpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKGF0b21TdGF0ZS5tICYmICFhdG9tU3RhdGUubS5sLnNpemUgJiYgIUFycmF5LmZyb20oYXRvbVN0YXRlLm0udCkuc29tZSgoYSkgPT4ge1xuICAgICAgdmFyIF9hMjtcbiAgICAgIHJldHVybiAoX2EyID0gZW5zdXJlQXRvbVN0YXRlKGEpLm0pID09IG51bGwgPyB1bmRlZmluZWQgOiBfYTIuZC5oYXMoYXRvbSk7XG4gICAgfSkpIHtcbiAgICAgIGNvbnN0IG9uVW5tb3VudCA9IGF0b21TdGF0ZS5tLnU7XG4gICAgICBpZiAob25Vbm1vdW50KSB7XG4gICAgICAgIHVubW91bnRDYWxsYmFja3MuYWRkKG9uVW5tb3VudCk7XG4gICAgICB9XG4gICAgICBkZWxldGUgYXRvbVN0YXRlLm07XG4gICAgICAoX2EgPSBhdG9tU3RhdGUuaCkgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9hLmNhbGwoYXRvbVN0YXRlKTtcbiAgICAgIGZvciAoY29uc3QgYSBvZiBhdG9tU3RhdGUuZC5rZXlzKCkpIHtcbiAgICAgICAgY29uc3QgYU1vdW50ZWQgPSB1bm1vdW50QXRvbShhLCBlbnN1cmVBdG9tU3RhdGUoYSkpO1xuICAgICAgICBhTW91bnRlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogYU1vdW50ZWQudC5kZWxldGUoYXRvbSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gYXRvbVN0YXRlLm07XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZUF0b20gPSAoYXRvbSwgbGlzdGVuZXIpID0+IHtcbiAgICBjb25zdCBhdG9tU3RhdGUgPSBlbnN1cmVBdG9tU3RhdGUoYXRvbSk7XG4gICAgY29uc3QgbW91bnRlZCA9IG1vdW50QXRvbShhdG9tLCBhdG9tU3RhdGUpO1xuICAgIGNvbnN0IGxpc3RlbmVycyA9IG1vdW50ZWQubDtcbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICBmbHVzaENhbGxiYWNrcygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBsaXN0ZW5lcnMuZGVsZXRlKGxpc3RlbmVyKTtcbiAgICAgIHVubW91bnRBdG9tKGF0b20sIGF0b21TdGF0ZSk7XG4gICAgICBmbHVzaENhbGxiYWNrcygpO1xuICAgIH07XG4gIH07XG4gIGNvbnN0IHVuc3RhYmxlX2Rlcml2ZSA9IChmbikgPT4gYnVpbGRTdG9yZSguLi5mbiguLi5zdG9yZUFyZ3MpKTtcbiAgY29uc3Qgc3RvcmUgPSB7XG4gICAgZ2V0OiByZWFkQXRvbSxcbiAgICBzZXQ6IHdyaXRlQXRvbSxcbiAgICBzdWI6IHN1YnNjcmliZUF0b20sXG4gICAgdW5zdGFibGVfZGVyaXZlXG4gIH07XG4gIHJldHVybiBzdG9yZTtcbn07XG5jb25zdCBkZXJpdmVEZXZTdG9yZVJldjQgPSAoc3RvcmUpID0+IHtcbiAgY29uc3QgZGVidWdNb3VudGVkQXRvbXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBsZXQgc2F2ZWRHZXRBdG9tU3RhdGU7XG4gIGxldCBpblJlc3RvcmVBdG9tID0gMDtcbiAgY29uc3QgZGVyaXZlZFN0b3JlID0gc3RvcmUudW5zdGFibGVfZGVyaXZlKCguLi5zdG9yZUFyZ3MpID0+IHtcbiAgICBjb25zdCBbZ2V0QXRvbVN0YXRlLCBzZXRBdG9tU3RhdGUsICwgYXRvbVdyaXRlXSA9IHN0b3JlQXJncztcbiAgICBzYXZlZEdldEF0b21TdGF0ZSA9IGdldEF0b21TdGF0ZTtcbiAgICBzdG9yZUFyZ3NbMV0gPSBmdW5jdGlvbiBkZXZTZXRBdG9tU3RhdGUoYXRvbSwgYXRvbVN0YXRlKSB7XG4gICAgICBzZXRBdG9tU3RhdGUoYXRvbSwgYXRvbVN0YXRlKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsTW91bnRlZCA9IGF0b21TdGF0ZS5oO1xuICAgICAgYXRvbVN0YXRlLmggPSAoKSA9PiB7XG4gICAgICAgIG9yaWdpbmFsTW91bnRlZCA9PSBudWxsID8gdW5kZWZpbmVkIDogb3JpZ2luYWxNb3VudGVkKCk7XG4gICAgICAgIGlmIChhdG9tU3RhdGUubSkge1xuICAgICAgICAgIGRlYnVnTW91bnRlZEF0b21zLmFkZChhdG9tKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWJ1Z01vdW50ZWRBdG9tcy5kZWxldGUoYXRvbSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfTtcbiAgICBzdG9yZUFyZ3NbM10gPSBmdW5jdGlvbiBkZXZBdG9tV3JpdGUoYXRvbSwgZ2V0dGVyLCBzZXR0ZXIsIC4uLmFyZ3MpIHtcbiAgICAgIGlmIChpblJlc3RvcmVBdG9tKSB7XG4gICAgICAgIHJldHVybiBzZXR0ZXIoYXRvbSwgLi4uYXJncyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXRvbVdyaXRlKGF0b20sIGdldHRlciwgc2V0dGVyLCAuLi5hcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBzdG9yZUFyZ3M7XG4gIH0pO1xuICBjb25zdCBzYXZlZFN0b3JlU2V0ID0gZGVyaXZlZFN0b3JlLnNldDtcbiAgY29uc3QgZGV2U3RvcmUgPSB7XG4gICAgLy8gc3RvcmUgZGV2IG1ldGhvZHMgKHRoZXNlIGFyZSB0ZW50YXRpdmUgYW5kIHN1YmplY3QgdG8gY2hhbmdlIHdpdGhvdXQgbm90aWNlKVxuICAgIGRldjRfZ2V0X2ludGVybmFsX3dlYWtfbWFwOiAoKSA9PiAoe1xuICAgICAgZ2V0OiAoYXRvbSkgPT4ge1xuICAgICAgICBjb25zdCBhdG9tU3RhdGUgPSBzYXZlZEdldEF0b21TdGF0ZShhdG9tKTtcbiAgICAgICAgaWYgKCFhdG9tU3RhdGUgfHwgYXRvbVN0YXRlLm4gPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdG9tU3RhdGU7XG4gICAgICB9XG4gICAgfSksXG4gICAgZGV2NF9nZXRfbW91bnRlZF9hdG9tczogKCkgPT4gZGVidWdNb3VudGVkQXRvbXMsXG4gICAgZGV2NF9yZXN0b3JlX2F0b21zOiAodmFsdWVzKSA9PiB7XG4gICAgICBjb25zdCByZXN0b3JlQXRvbSA9IHtcbiAgICAgICAgcmVhZDogKCkgPT4gbnVsbCxcbiAgICAgICAgd3JpdGU6IChfZ2V0LCBzZXQpID0+IHtcbiAgICAgICAgICArK2luUmVzdG9yZUF0b207XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2F0b20sIHZhbHVlXSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgaWYgKGhhc0luaXRpYWxWYWx1ZShhdG9tKSkge1xuICAgICAgICAgICAgICAgIHNldChhdG9tLCB2YWx1ZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgLS1pblJlc3RvcmVBdG9tO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHNhdmVkU3RvcmVTZXQocmVzdG9yZUF0b20pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIE9iamVjdC5hc3NpZ24oZGVyaXZlZFN0b3JlLCBkZXZTdG9yZSk7XG59O1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoKSA9PiB7XG4gIGNvbnN0IGF0b21TdGF0ZU1hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBzdG9yZSA9IGJ1aWxkU3RvcmUoXG4gICAgKGF0b20pID0+IGF0b21TdGF0ZU1hcC5nZXQoYXRvbSksXG4gICAgKGF0b20sIGF0b21TdGF0ZSkgPT4gYXRvbVN0YXRlTWFwLnNldChhdG9tLCBhdG9tU3RhdGUpLmdldChhdG9tKSxcbiAgICAoYXRvbSwgLi4ucGFyYW1zKSA9PiBhdG9tLnJlYWQoLi4ucGFyYW1zKSxcbiAgICAoYXRvbSwgLi4ucGFyYW1zKSA9PiBhdG9tLndyaXRlKC4uLnBhcmFtcyksXG4gICAgKGF0b20sIC4uLnBhcmFtcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGF0b20udW5zdGFibGVfb25Jbml0KSA9PSBudWxsID8gdW5kZWZpbmVkIDogX2EuY2FsbChhdG9tLCAuLi5wYXJhbXMpO1xuICAgIH0sXG4gICAgKGF0b20sIC4uLnBhcmFtcykgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgcmV0dXJuIChfYSA9IGF0b20ub25Nb3VudCkgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IF9hLmNhbGwoYXRvbSwgLi4ucGFyYW1zKTtcbiAgICB9XG4gICk7XG4gIGlmICgoaW1wb3J0Lm1ldGEuZW52ID8gaW1wb3J0Lm1ldGEuZW52Lk1PREUgOiB1bmRlZmluZWQpICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgIHJldHVybiBkZXJpdmVEZXZTdG9yZVJldjQoc3RvcmUpO1xuICB9XG4gIHJldHVybiBzdG9yZTtcbn07XG5sZXQgZGVmYXVsdFN0b3JlO1xuY29uc3QgZ2V0RGVmYXVsdFN0b3JlID0gKCkgPT4ge1xuICBpZiAoIWRlZmF1bHRTdG9yZSkge1xuICAgIGRlZmF1bHRTdG9yZSA9IGNyZWF0ZVN0b3JlKCk7XG4gICAgaWYgKChpbXBvcnQubWV0YS5lbnYgPyBpbXBvcnQubWV0YS5lbnYuTU9ERSA6IHVuZGVmaW5lZCkgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICBnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fIHx8IChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fID0gZGVmYXVsdFN0b3JlKTtcbiAgICAgIGlmIChnbG9iYWxUaGlzLl9fSk9UQUlfREVGQVVMVF9TVE9SRV9fICE9PSBkZWZhdWx0U3RvcmUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIFwiRGV0ZWN0ZWQgbXVsdGlwbGUgSm90YWkgaW5zdGFuY2VzLiBJdCBtYXkgY2F1c2UgdW5leHBlY3RlZCBiZWhhdmlvciB3aXRoIHRoZSBkZWZhdWx0IHN0b3JlLiBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL2pvdGFpL2Rpc2N1c3Npb25zLzIwNDRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFN0b3JlO1xufTtcblxuZXhwb3J0IHsgYXRvbSwgY3JlYXRlU3RvcmUsIGdldERlZmF1bHRTdG9yZSB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/jotai/esm/vanilla.mjs\n");

/***/ })

};
;